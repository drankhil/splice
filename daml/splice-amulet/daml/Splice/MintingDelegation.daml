module Splice.MintingDelegation where

import DA.Assert
import DA.Time
import Splice.AmuletRules
import Splice.Round
import Splice.Types
import Splice.Util
import Splice.ValidatorLicense

template MintingDelegationProposal
  with
    dso : Party
    beneficiary : Party
    delegate : Party
    expiresAt : Time
  where
    signatory dso, beneficiary
    observer delegate

    choice MintingDelegationProposal_Accept : MintingDelegationProposal_AcceptResult
      controller delegate
      do MintingDelegationProposal_AcceptResult <$> create MintingDelegation with
           dso
           beneficiary
           delegate
           expiresAt

    choice MiningDelegationProposal_Reject : ()
      controller delegate
      do pure ()

    choice MiningDelegationProposal_Withdraw : ()
      controller beneficiary
      do pure ()

    choice MintingDelegationProposal_Expire : ()
      with
        p : Party
      controller p
      do require ("Controller " <> show p <> " must be one of the stakeholders" <> show (stakeholder this)) (p `elem` stakeholder this)
         assertDeadlineExceeded "expiresAt" expiresAt
         pure ()

template MintingDelegation
  with
    dso : Party
    beneficiary : Party
    delegate : Party
    expiresAt : Time
  where
    signatory dso, beneficiary, delegate

    nonconsuming choice MintingDelegation_RecordValidatorLivenessActivity : ValidatorLicense_RecordValidatorLivenessActivityResult
      with
        validatorLicenseCid : ContractId ValidatorLicense
        openRoundCid : ContractId OpenMiningRound
      controller delegate
      do _ <- fetchChecked (ForOwner with dso, owner = beneficiary) validatorLicenseCid
         exercise validatorLicenseCid (ValidatorLicense_RecordValidatorLivenessActivity openRoundCid)

    nonconsuming choice MintingDelegation_Mint : TransferResult
      with
        inputs : [TransferInput]
        context : PaymentTransferContext
      controller delegate
      do assertWithinDeadline "expiresAt" expiresAt
         -- require "Minting is unfeatured" (context.context.featuredAppRightCid == None)
         -- TODO: do we want to allow amulet inputs? Seems like other than contention there is no real downside and merging
         -- usually is still reasonable.
         exercise context.amuletRules AmuletRules_Transfer with
           transfer = Transfer with
             sender = beneficiary
             provider = beneficiary -- TODO: consider whether the provider should be the delegate, perhaps irrelevant if fees go to zero
             inputs
             outputs = []
             beneficiaries = None
           context = context.context
           expectedDso = Some dso

    choice MiningDelegation_Reject : ()
      controller delegate
      do pure ()

    choice MiningDelegation_Withdraw : ()
      controller beneficiary
      do pure ()

    choice MintingDelegation_Expire : ()
      with
        p : Party
      controller p
      do require ("Controller " <> show p <> " must be one of the stakeholders" <> show (stakeholder this)) (p `elem` stakeholder this)
         assertDeadlineExceeded "expiresAt" expiresAt
         pure ()

    -- We do not charge a fee for MiningDelegation but we make them expire
    -- and force paying traffic to renew them to protect against attacks.
    choice MintingDelegation_Renew : ContractId MintingDelegation
      with
        renewalDuration : RelTime
      controller delegate
      do require ("renewalDuration " <> show renewalDuration <> " must be positive") (renewalDuration > seconds 0)
         -- TODO: Consider making maximum renewalDuration configurable
         require ("renewalDuration must not be more than 30 days " <> show renewalDuration <> " must be positive") (renewalDuration <= days 30)
         -- TODO: Consider enforcing that this is "close" to expiry, e.g., not more than 10 days before expiry
         create this with expiresAt = this.expiresAt `addRelTime` renewalDuration

data MintingDelegationProposal_AcceptResult = MintingDelegationProposal_AcceptResult
  with
    mintingDelegationCid : ContractId MintingDelegation
  deriving (Show, Eq)
